import pandas as pd
import tkinter as tk
from tkinter import ttk, messagebox

# Load Excel workbook and relevant sheets
EXCEL_FILE = "product_database.xlsx"
xls = pd.ExcelFile(EXCEL_FILE)
sheet_names = [name for name in xls.sheet_names if name.upper().startswith("PROFILE")]
sheets_dict = {name: xls.parse(name) for name in sheet_names}

# Clean and normalize each sheet
for name, df in sheets_dict.items():
    df["Width(mm)"] = pd.to_numeric(df["Width(mm)"], errors="coerce")
    df["Length(mm)"] = pd.to_numeric(df["Length(mm)"], errors="coerce")
    df["Type"] = df["Type"].astype(str).str.strip().str.upper()
    df["Price(RM)"] = df["Price(RM)"].astype(str).str.replace("/M", "").str.replace(" ", "").str.strip()
    df["Total"] = df["Total"].astype(str).str.strip()
    sheets_dict[name] = df

# Initialize GUI
root = tk.Tk()
root.title("Multi-Product Price Calculator")
root.geometry("720x740")

inputs = {}

def create_entry(key, label, row):
    tk.Label(root, text=label).grid(row=row, column=0, padx=10, pady=5, sticky='w')
    entry = tk.Entry(root)
    entry.grid(row=row, column=1, padx=10, pady=5)
    inputs[key] = entry

# Sheet selector
tk.Label(root, text="Items").grid(row=0, column=0, padx=10, pady=5, sticky='w')
sheet_var = tk.StringVar()
sheet_dropdown = ttk.Combobox(root, textvariable=sheet_var, values=sheet_names, state="readonly")
sheet_dropdown.grid(row=0, column=1, padx=10, pady=5)
sheet_var.set(sheet_names[0])

# Width dropdown
tk.Label(root, text="Width (mm)").grid(row=1, column=0, padx=10, pady=5, sticky='w')
width_var = tk.StringVar()
width_dropdown = ttk.Combobox(root, textvariable=width_var, state="readonly")
width_dropdown.grid(row=1, column=1, padx=10, pady=5)

# Length dropdown
tk.Label(root, text="Length (mm)").grid(row=2, column=0, padx=10, pady=5, sticky='w')
length_var = tk.StringVar()
length_dropdown = ttk.Combobox(root, textvariable=length_var, state="readonly")
length_dropdown.grid(row=2, column=1, padx=10, pady=5)

# Type dropdown
tk.Label(root, text="Type").grid(row=3, column=0, padx=10, pady=5, sticky='w')
type_var = tk.StringVar()
type_dropdown = ttk.Combobox(root, textvariable=type_var, state="readonly")
type_dropdown.grid(row=3, column=1, padx=10, pady=5)

# Entries for user inputs
create_entry("total_m", "Total (mm)", 4)
create_entry("quantity", "Quantity (pieces)", 5)
create_entry("holes", "Holes[thread] (If none put 0)", 6)

# Result display
result_box = tk.Text(root, height=20, width=85)
result_box.grid(row=8, column=0, columnspan=2, padx=10, pady=10)

def update_dropdowns(*args):
    df = sheets_dict.get(sheet_var.get())
    if df is not None:
        width_options = sorted(df["Width(mm)"].dropna().unique().tolist())
        length_options = sorted(df["Length(mm)"].dropna().unique().tolist())
        type_options = sorted(df["Type"].dropna().unique().tolist())

        width_dropdown["values"] = width_options
        length_dropdown["values"] = length_options
        type_dropdown["values"] = type_options

        if width_options:
            width_var.set(str(width_options[0]))
        if length_options:
            length_var.set(str(length_options[0]))
        if type_options:
            type_var.set(type_options[0])

sheet_var.trace_add("write", update_dropdowns)
update_dropdowns()

def search_and_calculate():
    result_box.delete("1.0", tk.END)
    df = sheets_dict.get(sheet_var.get())
    if df is None:
        result_box.insert(tk.END, "Sheet not found.\n")
        return

    try:
        width = int(width_var.get())
        length = float(length_var.get())
        height = float(inputs["total_m"].get())
        quantity = int(inputs["quantity"].get())
        holes = int(inputs["holes"].get())
        type_ = type_var.get().strip().upper()
    except ValueError:
        messagebox.showerror("Input Error", "Please enter valid numeric values.")
        return

    if type_ not in ["L", "XL"]:
        messagebox.showerror("Input Error", "Type must be 'L' or 'XL'.")
        return

    filtered = df[
        (df["Width(mm)"] == width) &
        (df["Length(mm)"] == length) &
        (df["Type"] == type_)
    ]

    if filtered.empty:
        result_box.insert(tk.END, "No matching profile found.\n")
        return

    part_no = filtered.iloc[0]["PART NO"]
    desc = filtered.iloc[0].get("DESCRIPTION", "â€”")
    result_box.insert(tk.END, f"Sheet: {sheet_var.get()}\n")
    result_box.insert(tk.END, f"Part No: {part_no}\n")
    result_box.insert(tk.END, f"Description: {desc}\n")
    result_box.insert(tk.END, f"Width: {width} mm | Length: {length} mm | Type: {type_}\n")

    total_products = (height * quantity)/1000  # new matching logic
    matched_price = None

    for _, row in filtered.iterrows():
        bracket_text = str(row["Total"]).strip()
        try:
            price = float(row["Price(RM)"])
        except ValueError:
            continue


        try:
            val = float(bracket_text.strip("<>M= "))
            if bracket_text.startswith("<") and total_products < val:
                matched_price = price
                break
            elif bracket_text.startswith(">") and total_products > val:
                matched_price = price
            elif bracket_text.startswith("=") and total_products == val:
                matched_price = price
                break
        except:
            continue

    if not matched_price:
        result_box.insert(tk.END, "\nNo price bracket matched the total products.\n")
        return

    cuts = quantity * 2
    material_cost = matched_price * total_products
    cut_cost = cuts * 3
    hole_cost = holes * 8
    grand_total = material_cost + cut_cost + hole_cost


    result_box.insert(tk.END, f"\nGrand Total: RM {grand_total:.2f}\n")

# Run button
search_btn = tk.Button(root, text="Calculate Price", command=search_and_calculate, bg="lightblue", width=20)
search_btn.grid(row=7, column=0, columnspan=2, pady=10)

root.mainloop()